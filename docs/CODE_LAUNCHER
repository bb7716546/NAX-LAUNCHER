# =================================================
# NAX Launcher (FINAL â€“ CRASH SAFE)
# Version groups: classic / alpha / beta / release /
# snapshot / installed
# Version-aware Java manager (Beta-safe)
# Java version indicator (corner)
# Discord crash reporter (auto-send)
# Install + Launch lock
# Solid blue background
# Installs to C:\NAX_LAUNCHER\
# Made by bb771 and the help of chat-gpt
# =================================================

import sys, os, json, socket, subprocess, threading, hashlib, stat, shutil, requests
import tkinter as tk
from tkinter import ttk, messagebox, font as tkfont
import minecraft_launcher_lib
import traceback
from datetime import datetime

# ---------- PYTHON VERSION CHECK ----------
if sys.version_info < (3, 10) or sys.version_info >= (3, 13):
    raise RuntimeError("Use Python 3.10 â€“ 3.12 (3.11 recommended)")

# ---------- PATHS ----------
ROOT_DIR = r"C:\NAX_LAUNCHER"
MC_DIR = os.path.join(ROOT_DIR, "minecraft")
JAVA_DIR = os.path.join(ROOT_DIR, "java")
STATE_FILE = os.path.join(ROOT_DIR, "nax_state.json")
ID_FILE = os.path.join(ROOT_DIR, ".nax_id.dat")
HASH_FILE = os.path.join(ROOT_DIR, ".nax_id.sig")
FONT_FILE = "Minecraft.ttf"

CRASH_DIR = os.path.join(ROOT_DIR, "crash_reports")
os.makedirs(CRASH_DIR, exist_ok=True)

DISCORD_WEBHOOK_URL = (
    "https://discord.com/api/webhooks/"
    "1459371304867332187/"
    "H91rqIKxUgwzWhiiz0YEjfYNtzQjON-s9adyvRPKUinyaFfxf34HeHarWJXHQlcl0ycm"
)

os.makedirs(MC_DIR, exist_ok=True)
os.makedirs(JAVA_DIR, exist_ok=True)

# ---------- CRASH REPORTER ----------
def send_crash_to_discord(title: str, body: str):
    payload = {
        "username": "NAX Crash Reporter",
        "embeds": [{
            "title": title,
            "description": body[:3900],
            "color": 0xFF0000
        }]
    }
    try:
        requests.post(DISCORD_WEBHOOK_URL, json=payload, timeout=5)
    except:
        pass

def log_crash(exc: Exception):
    ts = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    path = os.path.join(CRASH_DIR, f"crash_{ts}.txt")
    trace = traceback.format_exc()

    with open(path, "w", encoding="utf-8") as f:
        f.write("NAX Launcher Crash Report\n")
        f.write(f"Time: {ts}\n")
        f.write(f"Python: {sys.version}\n\n")
        f.write(trace)

    send_crash_to_discord(
        "ðŸš¨ NAX Launcher Crash",
        f"```py\n{trace}\n```"
    )
    return path

# ---------- LOCK ----------
launcher_locked = False

def lock_launcher(text):
    global launcher_locked
    launcher_locked = True
    play_btn.config(state="disabled", text=text)

def unlock_launcher():
    global launcher_locked
    launcher_locked = False
    play_btn.config(state="normal", text="PLAY")
    status.set("Ready")

# ---------- INTERNET ----------
def has_internet():
    try:
        socket.create_connection(("8.8.8.8", 53), timeout=2)
        return True
    except:
        return False

# ---------- STATE (CRASH SAFE) ----------
def load_state():
    # keep next_id for backward compatibility (even if no longer used)
    default = {"next_id": 1, "ram": 4, "group": "release"}
    if not os.path.exists(STATE_FILE):
        return default
    try:
        with open(STATE_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
            if not isinstance(data, dict):
                return default
    except:
        return default
    for k in default:
        data.setdefault(k, default[k])
    return data

def save_state():
    with open(STATE_FILE, "w", encoding="utf-8") as f:
        json.dump(state, f)

state = load_state()

# ---------- NAX ID ----------
def hash_data(s): 
    return hashlib.sha256(s.encode()).hexdigest()

def write_locked(path, data):
    with open(path, "w", encoding="utf-8") as f:
        f.write(data)
    os.chmod(path, stat.S_IREAD)

def load_nax_id():
    """
    FIXED:
    - Offline -> "NAX"
    - Online  -> persistent random 4-digit name like NAX3945
      stored in ID_FILE with hash in HASH_FILE (tamper check)
    """
    if not has_internet():
        return "NAX"

    # If missing or invalid, generate a new random 4-digit ID (NOT NAX01)
    if not os.path.exists(ID_FILE) or not os.path.exists(HASH_FILE):
        nid = f"NAX{__import__('random').randint(1000, 9999)}"
        write_locked(ID_FILE, nid)
        write_locked(HASH_FILE, hash_data(nid))
        return nid

    # Validate stored id + hash
    with open(ID_FILE, encoding="utf-8") as f:
        nid = f.read().strip()
    with open(HASH_FILE, encoding="utf-8") as f:
        sig = f.read().strip()

    # If tampered -> delete + regenerate
    if hash_data(nid) != sig or not nid.startswith("NAX") or len(nid) != 7 or not nid[3:].isdigit():
        try:
            os.chmod(ID_FILE, stat.S_IWRITE)
            os.chmod(HASH_FILE, stat.S_IWRITE)
        except:
            pass
        try:
            os.remove(ID_FILE)
            os.remove(HASH_FILE)
        except:
            pass
        return load_nax_id()

    return nid

NAX_NAME = load_nax_id()

# ---------- JAVA CLASSIFIER ----------
def classify_version(v):
    v = v.lower()
    if v.startswith("b") or "alpha" in v or "classic" in v:
        return ("Java 8", None)
    if "snapshot" in v or "w" in v:
        return ("Java 21", 21)
    if v.startswith("1."):
        parts = v.split(".")
        minor = int(parts[1]) if parts[1].isdigit() else 20
        patch = int(parts[2]) if len(parts) >= 3 and parts[2].isdigit() else 0
        if minor <= 16:
            return ("Java 8", None)
        if minor < 20:
            return ("Java 17", 17)
        if patch >= 5:
            return ("Java 21", 21)
        return ("Java 17", 17)
    return ("Java 8", None)

def resolve_java(version):
    label, major = classify_version(version)
    java_label.set(label)
    if major is None:
        if not shutil.which("java"):
            raise RuntimeError("Java 8 required for Beta/Alpha/Classics")
        return None
    base = os.path.join(JAVA_DIR, f"java{major}")
    for r, _, f in os.walk(base):
        if "java.exe" in f:
            return os.path.join(r, "java.exe")
    return shutil.which("java")

# ---------- VERSION LISTS ----------
VERSIONS = minecraft_launcher_lib.utils.get_version_list()

def get_installed_versions():
    path = os.path.join(MC_DIR, "versions")
    if not os.path.isdir(path):
        return []
    return sorted(v for v in os.listdir(path)
                  if os.path.isdir(os.path.join(path, v)))

def get_versions(group):
    if group == "installed":
        return get_installed_versions()
    if group == "classic":
        return [v["id"] for v in VERSIONS if v["type"] == "old_alpha"]
    if group == "alpha":
        return [v["id"] for v in VERSIONS if "a" in v["id"]]
    if group == "beta":
        return [v["id"] for v in VERSIONS if v["id"].startswith("b")]
    if group == "snapshot":
        return [v["id"] for v in VERSIONS if v["type"] == "snapshot"]
    return [v["id"] for v in VERSIONS if v["type"] == "release"]

# ---------- LAUNCH ----------
def launch_game():
    if launcher_locked:
        return
    version = version_box.get()
    if not version:
        return
    try:
        lock_launcher("INSTALLING..." if not os.path.exists(
            os.path.join(MC_DIR, "versions", version)) else "LOADING...")
        java_path = resolve_java(version)

        minecraft_launcher_lib.install.install_minecraft_version(version, MC_DIR)

        opts = {
            "username": NAX_NAME,
            "uuid": "0",
            "token": "0",
            "jvmArguments": [f"-Xmx{ram_slider.get()}G", "-Xms1G"]
        }
        if java_path:
            opts["executablePath"] = java_path

        subprocess.Popen(
            minecraft_launcher_lib.command.get_minecraft_command(
                version, MC_DIR, opts
            )
        ).wait()
    except Exception as e:
        crash = log_crash(e)
        messagebox.showerror(
            "NAX Launcher Crashed",
            f"A crash occurred.\n\nCrash report sent.\n\n{crash}"
        )
    finally:
        unlock_launcher()

def launch_thread():
    threading.Thread(target=launch_game, daemon=True).start()

# ---------- GUI ----------
root = tk.Tk()
root.attributes("-fullscreen", True)
root.bind("<Escape>", lambda e: root.attributes("-fullscreen", False))
root.configure(bg="#3C7DD9")
tk.Frame(root, bg="#3C7DD9").place(x=0, y=0, relwidth=1, relheight=1)

if os.path.exists(FONT_FILE):
    mc_font = tkfont.Font(file=FONT_FILE, size=12)
    title_font = tkfont.Font(file=FONT_FILE, size=28)
else:
    mc_font = ("Segoe UI", 11, "bold")
    title_font = ("Segoe UI", 24, "bold")

tk.Label(root, text=NAX_NAME, font=mc_font,
         fg="#55FF55", bg="#3C7DD9").place(x=20, y=20)

java_label = tk.StringVar(value="Java ?")
tk.Label(root, textvariable=java_label,
         font=mc_font, fg="white", bg="#3C7DD9").place(x=20, y=45)

frame = tk.Frame(root, bg="#000000", bd=3)
frame.place(relx=0.5, rely=0.5, anchor="center")

tk.Label(frame, text="NAX LAUNCHER",
         font=title_font, fg="#55FF55", bg="#000000").pack(pady=10)

group_box = ttk.Combobox(
    frame,
    values=["classic", "alpha", "beta", "release", "snapshot", "installed"],
    state="readonly", width=24
)
group_box.set(state["group"])
group_box.pack(pady=3)

version_box = ttk.Combobox(frame, state="readonly", width=32)
version_box.pack(pady=5)

def update_versions(_=None):
    state["group"] = group_box.get()
    versions = get_versions(state["group"])
    version_box["values"] = versions
    if versions:
        version_box.set(versions[0])
        java_label.set(classify_version(versions[0])[0])
    save_state()

group_box.bind("<<ComboboxSelected>>", update_versions)
update_versions()

ram_label = tk.Label(frame, text=f"RAM: {state['ram']} GB",
                     font=mc_font, fg="white", bg="#000000")
ram_label.pack()

ram_slider = tk.Scale(frame, from_=1, to=16, orient="horizontal",
                      bg="#000000", fg="white",
                      troughcolor="#333333", highlightthickness=0)
ram_slider.set(state["ram"])
ram_slider.pack()

ram_slider.config(command=lambda v: (
    ram_label.config(text=f"RAM: {int(float(v))} GB"),
    state.__setitem__("ram", int(float(v))),
    save_state()
))

play_btn = tk.Button(frame, text="PLAY",
                     font=mc_font, width=25,
                     command=launch_thread)
play_btn.pack(pady=8)

row = tk.Frame(frame, bg="#000000")
row.pack(pady=6)

tk.Button(row, text="Credits", font=mc_font,
          command=lambda: messagebox.showinfo(
              "Credits", "NAX Launcher\n\nMade by bb771")
).pack(side="left", padx=10)

tk.Button(row, text="Quit", font=mc_font,
          command=root.destroy).pack(side="right", padx=10)

status = tk.StringVar(value="Ready")
tk.Label(root, textvariable=status,
         font=mc_font, fg="white", bg="#3C7DD9").pack(side="bottom", pady=10)

try:
    root.mainloop()
except Exception as e:
    crash = log_crash(e)
    messagebox.showerror(
        "NAX Launcher Crashed",
        f"A fatal error occurred.\n\nCrash report sent.\n\n{crash}"
    )
